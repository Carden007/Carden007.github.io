<!doctype html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="技术博客之多线程管理">
<meta property="og:type" content="article">
<meta property="og:title" content="线程管理">
<meta property="og:url" content="http://yoursite.com/2017/06/09/线程管理/index.html">
<meta property="og:site_name" content="Carden&#39;s Blog">
<meta property="og:description" content="技术博客之多线程管理">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1881355-d825de064f61a951.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/645301-c79b90a8b2e8224e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-06-15T02:09:42.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="线程管理">
<meta name="twitter:description" content="技术博客之多线程管理">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1881355-d825de064f61a951.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/06/09/线程管理/"/>





  <title>线程管理 | Carden's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  















  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Carden's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/09/线程管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Carden007">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://static.pexels.com/photos/33392/portrait-bird-nature-wild.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carden's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">线程管理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-09T10:16:21+08:00">
                2017-06-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="http://upload-images.jianshu.io/upload_images/1881355-d825de064f61a951.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt=""></p>
<p>技术博客之多线程管理<a id="more"></a></p>
<blockquote>
<p>#术语</p>
</blockquote>
<p><strong>任务</strong>：准备执行的操作，通常就是一个block块</p>
<p><strong>队列</strong>：queue，存放任务，管理任务</p>
<p><strong>进程</strong>——苹果电脑里的活动监视器App里详细罗列了操作系统此时此刻正在运行的所有程序，同时标明了每一个进行的程序的所有线程。</p>
<p><strong>线程</strong>——将一个程序都转换成汇编的CPU命令时，由一堆不分叉的Cpu指令组成的路径（主线程命令和分线程命令）</p>
<p><strong>多线程编程</strong>——由多条不分叉的CPU指令所组成的路径就是多线程编程。优点：提高资源利用率和程序执行效率，用户体验    缺点：1、上下文切换频率太高会影响性能 2、资源竞争—&gt;上锁（类似单例）3、死锁  4、开辟的线程其实类似于创建一个对象，会消耗大量内存（内核数据结构（大约1KB）、栈空间（子线程512KB、主线程1MB，也可以使用-setStackSize:设置，但必须是4K的倍数，而且最小是16K），创建线程大约需要90毫秒的创建时间）5、程序设计更加复杂：比如线程之间的通信、多线程的数据共享</p>
<p><strong>CPU包括</strong>——1、物理CPU（硬件）2、CPU核 （一个物理CPU可以虚拟出多个CPU核，一个CPU核就相当于一个CPU的功能，可以分身，一个CPU核一个时刻只能执行一个CPU命令）</p>
<p><strong>并发</strong>——虽然同一时间，CPU只能处理1条线程，只有1条线程在执行，但是CPU可以快速地在多条线程之间调度切换，如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。当然如果线程过多，会消耗大量的CPU资源，同时每条线程被调度执行的频次会降低（线程的执行效率降低）</p>
<blockquote>
<p>#多核就快</p>
</blockquote>
<p>首先谈一谈就是程序执行的本质，我们写的代码都首先是转化成一行行的汇编代码才能被计算机所识别。这一行行的汇编代码其实也叫做CPU指令。这里面就涉及到CPU了，CPU就是读取这些指令的工具。当然，有一种汇编代码也就是CPU指令的结构是从头到尾不间断的，也就是这些CPU指令一点也没有分叉，从头到尾都是直路，就像高速公路一样，只有直路，没有岔路。可是程序的魅力就在于，遇到分岔路时或更复杂的十字路口时应该怎么办？肯定不能一根筋呀！于是CPU厂商就想到了一个方法，就是分身术，当遇到分叉路的时候就像孙悟空一样，复制一个自己来走新出现的分岔路。可是问题来了，如果第二次又遇到分叉路怎么办呢？两种思路，第一种再复制一个自己。第二种就是用那个复制的自己轮流前进。第一种方法主要受到CPU本身性能的局限。有的CPU只能复制一个自己，算上本身总共才两个。也有的CPU可以复制三个自己，算上本身总共有4个。这种具体去跑马路的车就叫做CPU核，所以你会发现，CPU越强大，也就是能够复制的自己越多，能够同时走的分叉路就越多，自然而然，四核就是比双核快。第二种方法就是让CPU的寄存器不断受到考验，当CPU分配那个复制的自己在那一条道路上奔跑时，必须时时记录下来这个复制的自己已经在每一条分叉路上已经跑了多远，并需要准确无误的保存在寄存器中，然后当CPU再一次将那个复制的自己放在相应地分岔路上继续跑时，就会读取寄存器里面的数据来继续前进。</p>
<blockquote>
<p>#主线程刷UI</p>
</blockquote>
<p>因为分线程不能刷新UI，但是有的时候明明看见刷新UI的代码写在了分线程里，但这并不代表这些代码会被分线程（复制的CPU核）执行，分线程主要是负责数据的下载。（两种情况：1、下载完成后主动回到主线程，告诉主线程自己已经完成下载，可以让主线程执行分线程没有资格执行的代码 2、需要主线程不定期去主动检查也就是说,尽管你把刷新UI的代码写在了分线程，但分线程只会执行其中的下载代码，根本不会执行刷新UI的代码。刷新UI的代码会等到主线程不定期的主动检查分线程时才会被执行。所以这样会出现一些延时，所以应该在下载完成后主动回到主线程）</p>
<blockquote>
<p>#时间片</p>
</blockquote>
<p>如果同一个CPU核去管理多个线程时，就会涉及到时间分配的问题，如果管理的是两个线程，线程一有10个命令，线程二有20个命令，CPU核会将时间片分配给两个线程，一一去执行完两个线程里面的所有命令，当一个线程切换到另一个线程时，系统会将当前线程的信息保存到寄存器中，等下次切换过来到时候唤醒寄存器，读取数据，从上一次的命令接着处理。这就是上下文切换。上下文切换——时间片分配（随机分配CPU核给那一个分线程，同时保存每一分线程上一次执行到的位置到寄存器中，告诉CPU核现在该从第几个CPU指令开始执行）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/645301-c79b90a8b2e8224e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS多线程"></p>
<blockquote>
<p>#NSThread</p>
</blockquote>
<ul>
<li>创建、启动线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</div><div class="line">[thread start];</div></pre></td></tr></table></figure>
<ul>
<li>线程相关用法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 获得当前线程</div><div class="line">NSThread *current = [NSThread currentThread];</div><div class="line"></div><div class="line">// 线程名字</div><div class="line">- (void)setName:(NSString *)name;</div><div class="line">- (NSString *)name;</div><div class="line"></div><div class="line">// 获得主线程</div><div class="line">+ (NSThread *)mainThread; </div><div class="line"></div><div class="line">// 判断是否主线程</div><div class="line">- (BOOL)isMainThread; </div><div class="line">+ (BOOL)isMainThread;</div><div class="line"></div><div class="line">// 创建线程后自动启动</div><div class="line">[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];</div><div class="line"></div><div class="line">// 隐式创建并启动线程</div><div class="line">[self performSelectorInBackground:@selector(run)  withObject:nil];</div><div class="line"></div><div class="line">// 阻塞（暂停）线程</div><div class="line">+ (void)sleepUntilDate:(NSDate *)date;</div><div class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</div><div class="line"></div><div class="line">// 强制停止线程</div><div class="line">+ (void)exit;</div></pre></td></tr></table></figure>
<blockquote>
<p>#GCD全称Grand Central Dispatch</p>
</blockquote>
<p>纯C语言函数，为多核并行运算而生，自动利用更多的CPU内核（比如双核、四核），且自动管理线程的生命周期（创建线程、调度任务、销毁线程），只需告诉GCD想要执行的任务，根本无需写任何管理线程生命周期的代码。队列管理任务执行顺序，同步异步决定任务执行线程。</p>
<ul>
<li>GCD创建并发队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 创建并发队列（队列名称，队列类型）</div><div class="line">dispatch_queue_t   myQueue = dispatch_queue_create(const char *label,   dispatch_queue_attr_t attr);</div><div class="line"></div><div class="line">// 获得默认并发队列（队列优先级，缺省参数0）</div><div class="line">dispatch_queue_t  systemQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); </div><div class="line"></div><div class="line">// 任务加入并发队列</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">        NSLog(@&quot;1-----%@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">        NSLog(@&quot;2-----%@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">        NSLog(@&quot;3-----%@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>GCD创建串行队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 创建串行队列（队列名称，队列类型）</div><div class="line">dispatch_queue_t  myQueue = dispatch_queue_create(&quot;串行队列&quot;, DISPATCH_QUEUE_SERIAL)；</div><div class="line"></div><div class="line">// 直接获取主队列 = 特殊串行队列</div><div class="line">dispatch_queue_t  systemQueue = dispatch_get_main_queue();</div><div class="line"></div><div class="line">// 任务加入串行队列</div><div class="line">dispatch_sync(queue, ^&#123;</div><div class="line">        NSLog(@&quot;1-----%@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">        NSLog(@&quot;2-----%@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">        NSLog(@&quot;3-----%@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>GCD同步执行任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 继续当前线程（队列，任务）</div><div class="line">dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</div></pre></td></tr></table></figure>
<ul>
<li>GCD异步执行任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 开启新线程（队列，任务）</div><div class="line">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</div></pre></td></tr></table></figure>
<ul>
<li>GCD线程通信</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 从子线程回到主线程</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">                // 执行耗时的异步操作...</div><div class="line"></div><div class="line"></div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">               // 回到主线程，执行UI刷新操作</div><div class="line"></div><div class="line">         &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 对比performSelector的线程通信</div><div class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;</div><div class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait;</div></pre></td></tr></table></figure>
<ul>
<li>GCD延时执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// GCD延时</div><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">    // 2秒后异步执行这里的代码...</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 对比performSelector延时</div><div class="line">[self performSelector:@selector(run) withObject:nil afterDelay:2.0];</div><div class="line"></div><div class="line">// 对比NSTimer延时</div><div class="line">[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(test) userInfo:nil repeats:NO];</div></pre></td></tr></table></figure>
<ul>
<li>GCD单例执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 保证某段代码在程序运行过程中只被执行1次</div><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">    // 只执行1次的代码(这里面默认是线程安全的)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>GCD创建定时器执行代码块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 创建Timer</div><div class="line">self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</div><div class="line">// 设置定时器的触发时间（1秒后）和时间间隔（每隔2秒）</div><div class="line">dispatch_source_set_timer(self.timer, dispatch_time(DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC), 2 * NSEC_PER_SEC, 0);</div><div class="line">// 设置Block回调</div><div class="line">dispatch_source_set_event_handler(self.timer, ^&#123;</div><div class="line">     NSLog(@&quot;Timer %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">// 开启定时器</div><div class="line">dispatch_resume(self.timer);</div><div class="line"></div><div class="line"></div><div class="line">// 取消置空定时器</div><div class="line">dispatch_cancel(self.timer);</div><div class="line">self.timer = nil;</div></pre></td></tr></table></figure>
<ul>
<li>GCD实现任务依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 队列组管理任务一和任务二</div><div class="line">dispatch_group_t group =  dispatch_group_create();</div><div class="line"></div><div class="line">// 异步执行任务一</div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    </div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 异步执行任务二</div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">   </div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 任务一和任务二都结束Block回调</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>GCD分线程遍历</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *   GCD快速异步遍历</div><div class="line"> */</div><div class="line">- (void)apply</div><div class="line">&#123;</div><div class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">    NSString *from = @&quot;初始路径&quot;;</div><div class="line">    NSString *to = @目标路径&quot;;</div><div class="line">    </div><div class="line">    NSFileManager *mgr = [NSFileManager defaultManager];</div><div class="line">    NSArray *subpaths = [mgr subpathsAtPath:from];</div><div class="line">    </div><div class="line">    dispatch_apply(subpaths.count, queue, ^(size_t index) &#123;</div><div class="line">        NSString *subpath = subpaths[index];</div><div class="line">        NSString *fromFullpath = [from stringByAppendingPathComponent:subpath];</div><div class="line">        NSString *toFullpath = [to stringByAppendingPathComponent:subpath];</div><div class="line">        [mgr moveItemAtPath:fromFullpath toPath:toFullpath error:nil]; // 剪切</div><div class="line">        NSLog(@&quot;%@---%@&quot;, [NSThread currentThread], subpath);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  对比传统异步遍历</div><div class="line"> */</div><div class="line">- (void)moveFile &#123;</div><div class="line">    NSString *from = @&quot;初始路径&quot;;</div><div class="line">    NSString *to = @目标路径&quot;;</div><div class="line"></div><div class="line">    NSFileManager *mgr = [NSFileManager defaultManager];</div><div class="line">    NSArray *subpaths = [mgr subpathsAtPath:from];</div><div class="line"></div><div class="line">    for (NSString *subpath in subpaths) &#123;</div><div class="line">        NSString *fromFullpath = [from stringByAppendingPathComponent:subpath];</div><div class="line">        NSString *toFullpath = [to stringByAppendingPathComponent:subpath];</div><div class="line"></div><div class="line">        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">            [mgr moveItemAtPath:fromFullpath toPath:toFullpath error:nil]; // 剪切</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>#NSOperation&amp;&amp;NSOperationQueue</p>
</blockquote>
<p>NSOperation是个并不具备封装操作能力的抽象类，必须使用它的子类来封装操作，NSOperation子类包括NSInvocationOperation、NSBlockOperation、自定义子类继承NSOperation。如果仅仅是实例化了一个操作对象，然后简简单单的执行这个操作的start方法，这样没有丝毫意义，还不如在.m文件里面写一个私有方法来得直接，可是一旦把实例化的NSOperation对象放到NSOperationQueue队列之中，添加到队列里面的操作对象会自动开始调用操作对象的start方法，开始异步在一条新的线程里面执行封装在操作对象里面的一系列代码，这就实现了分线程操作了，好神奇有木有！</p>
<ul>
<li>创建NSInvocationOperation操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//  创建NSInvocationOperation对象</div><div class="line">- (id)initWithTarget:(id)target selector:(SEL)sel object:(id)arg;</div><div class="line"></div><div class="line">//  默认同步，除非添加操作到队列</div><div class="line">- (void)addOperation:(NSOperation *)op;</div></pre></td></tr></table></figure>
<ul>
<li>创建NSBlockOperation操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//  创建NSBlockOperation</div><div class="line">+ (id)blockOperationWithBlock:(void (^)(void))block;</div><div class="line"></div><div class="line">//  添加更多操作（只要任务数&gt;1，就会异步执行操作）</div><div class="line">- (void)addExecutionBlock:(void (^)(void))block;</div></pre></td></tr></table></figure>
<ul>
<li>创建自定义NSOperation操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">重写父类NSOperation的main方法，在main方法里面写入我想要封装的执行的任务，但是有一点需要特别注意，就是自己写的这段代码很可能会是在子线程里面异步执行，既然是异步操作，自然无法访问主线程的自动释放池，对象的内存释放便是需要重点考虑的内容。经常的做法就是，在封装想要执行的代码之前，必须先判断一下这个操作对象是否已经被取消，因为一旦开始执行进入了子线程就无法在判断isCancelled这个属性了，所以必须在开始执行封装的代码之前，必须先判断这个操作对象是否已经被取消。如果判断已经取消，我需要做的就是一些内存的管理。</div></pre></td></tr></table></figure>
<ul>
<li>创建NSOperation操作依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 一定先让操作A执行完毕，然后才能执行操作B</div><div class="line">[operationB addDependency:operationA]; </div><div class="line">！！！一定注意不能相互依赖</div></pre></td></tr></table></figure>
<ul>
<li>监听NSOperation操作执行完毕</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void (^)(void))completionBlock;</div><div class="line">- (void)setCompletionBlock:(void (^)(void))block;</div></pre></td></tr></table></figure>
<ul>
<li>添加操作到NSOperationQueue对列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)addOperation:(NSOperation *)op;</div><div class="line">- (void)addOperationWithBlock:(void (^)(void))block;</div></pre></td></tr></table></figure>
<ul>
<li>设置操作对列NSOperationQueue最大并发数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)maxConcurrentOperationCount;</div><div class="line">- (void)setMaxConcurrentOperationCount:(NSInteger)cnt;</div></pre></td></tr></table></figure>
<ul>
<li>对列NSOperationQueue的取消、暂停、恢复</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//  取消队列操作</div><div class="line">- (void)cancelAllOperations;</div><div class="line">- (void)cancel；</div><div class="line"></div><div class="line">// 暂停Or恢复队列</div><div class="line">- (void)setSuspended:(BOOL)bool; </div><div class="line">- (BOOL)isSuspended;</div></pre></td></tr></table></figure>
<blockquote>
<p>#GCD和NSOperation的区别？</p>
</blockquote>
<p>GCD无法控制线程的最大并发数，而NSOperation可以控制同时进行的线程个数！</p>
<blockquote>
<p>#开辟多线程？</p>
</blockquote>
<ul>
<li><strong>performSelector</strong></li>
</ul>
<p>作为<code>NSObject</code>的类别，因此只要是控制器的对象就可以直接调用这个方法。而且不仅仅可以通过<code>performSelectorInBackground</code>将耗时操作放进分线程里，更可以通过<code>performSelectorOnMainThread</code>将分线程里的参数传递到主线程以便进一步操作，例如刷新<code>UI</code>。</p>
<ul>
<li><strong>NSThread线程类</strong></li>
</ul>
<p><code>thread</code>本身就是线的意思。通过<code>NSThread</code>类实例化一个对象。然后直接通过初始化方法就可以像为<code>UIButton</code>增添点击事件那样增添一个在分线程里进行的方法。而且可以传递给这个分线程方法一个无论什么对象类型的参数。但是特别注意：通过<code>NSThread</code>类实例化的对象所初始化增添的分线程方法必须通过[对象 start]方法表示开始执行分线程方法。而且无论第三方工具如何丰富，本质上都是对<code>NSThread</code>进行一系列操作。所以说在任何情况下都可以调用<code>[NSThread currentThread]</code>这个类方法获取到当前的线程信息，有点像代码版的活动监视器哈！这是苹果提供的三种方法里面相对轻量级的，但需要管理线程的生命周期、同步、加锁的问题，这会导致一定得性能开销。</p>
<ul>
<li><strong>GCD队列Grand Central Dispatch</strong></li>
</ul>
<p>伟大的中枢调度器，充分发挥CPU内核的性能，自动管理线程的生命周期，包括创建线程，调度任务和销毁线程。而且使用过程中只需添加任务即可，无需管理线程。</p>
<ul>
<li><strong>NSOperation</strong></li>
</ul>
<p>一块资源可能会被多个线程共享，通常添加互斥锁<code>@synchronized(self){}</code>来避免引发数据错乱和数据安全问题。但是添加互斥锁会影响手机的性能，所以尽量将加锁和资源抢夺业务的逻辑交给服务器端处理，线程不会孤立存在，子线程下载图片，在主线程刷新UI显示图片。使用<code>@synchronized(self的锁对象){}</code>包起来的代码同一时刻只能被一个线程执行，而且加锁的时候尽量缩小范围，范围越大就越消耗性能。</p>
<blockquote>
<p>#串行队列Vs并行队列？</p>
</blockquote>
<p><strong>相同点</strong>：</p>
<ul>
<li><p>创建方式都是<code>dispatch_queue_t queue</code>，只不过创建队列时的标志符后面的参数有了一些变化，主要有<code>（NULL， DISPATCH_QUEUE_SERIAL，DISPATCH_QUEUE_CONCURRENT）</code>三种类型。前两种等价都可以表示串行队列。而且有一个细节就是标识符的格式是否有要求一时确定不了！</p>
</li>
<li><p>往队列里添加任务的方式一模一样，都是<code>dispatch_async(queue, ^{})</code>这种格式。凡是创建的队列都是以分线程的形式存在。所以对于一个分线程队列来说就必须考虑如何返回到主线程。而且这也不是说纯粹意义上的将这个分线程注销，更多的是想将无法在分线程中执行的代码及时的传递到主线程以便进行下一步操作。</p>
</li>
<li><p>将分线程中下载完成的数据如何让以参数的形式传递到主线程呢？两种方法，方法1就是使用控制器的对象调用<code>performSelectorOnMainThread</code>方法。方法2就是通过<code>dispatch_queue_t mainQueue = dispatch_get_main_queue()</code>获取到主队列，这也就代表了主线程。通过在主队列中添加任务也就等于是通过主线程来执行分线程无法执行的代码。而且方法2还有一个优点就是，无需像方法一那样过于纠结于到底应该将分线程的什么参数传递出去，因为方法二是直接建立在分线程的基础上，本质上只是起一个临时调用主线程的功能，因此方法二可以直接调用分线程里的任何参数变量。</p>
</li>
<li><p>如果不理解什么是串行队列，其实主队列<code>dispatch_queue_t mainQueue = dispatch_get_main_queue()</code>就是一个典型的串行队列，无论你添加多少任务总是按照任务的添加顺序依次执行，没有例外。而且自始至终都是一个线程，而且这个线程就叫做主线程。</p>
</li>
</ul>
<p><strong>不同点</strong>：</p>
<ul>
<li><p>串行队列无论添加多少个任务都只是创建了一个分线程，而且执行任务的顺序严格按照添加任务的先后顺序进行。而对于并行队列而言，往并行对列中每增添一个任务就创建了一个分线程。也就是说并行队列中有多少个任务就有多少个分线程，我们也都知道，线程其实本质上也是一个对象，是对象就必须开辟内存，因此虽然说创建很多的分线程有利于获得良好的用户体验，但这对于用户终端的内存是一个极大的考验。</p>
</li>
<li><p>并行队列的任务因为是一个任务对应一个分线程。所以可以认为并行队列里的任务是同时进行的。所以最终并行队列里的哪一个任务最先执行结束的关键还在于任务的具体内容。</p>
</li>
<li><p>对于并行队列而言有一种很特殊的需求就是：我想准确地知道并行队列里的最后一个任务是什么时候执行完毕，然后我再进行下一部操作，因为通常情况下是无法准确地获取到现在并行队列的任务到底执行到了一个什么阶段。根本无法像串行队列那样通过添加任务的先后顺序来推断出到底哪一个任务结束后标志着队列任务全部结束！解决方案就是给并行队列添加一个<code>group</code>。同样需要通过<code>dispatch_queue_t  queue = dispatch_queue_create(&quot;123&quot;, DISPATCH_QUEUE_CONCURRENT)</code>先创建一个并行队列，然后通过<code>dispatch_group_t group = dispatch_group_create()</code>创建一个管理并行队列里所有任务的组。接着跟常规添加任务到并行队列不同的是：<code>dispatch_group_async(group, queue, ^{});</code>当然从分线程返回到主线程的方法<code>dispatch_async(dispatch_get_main_queue(), ^{});</code>并没有发生变化。把所有的任务添加到有管理组的并行队列中目的就是时刻监听并行队列里的任务的进行阶段，监听到并行队列里所有的任务全部结束时就会触发方法<code>dispatch_group_notify(group,dispatch_get_main_queue(),^{});</code>需要注意的是，这个方法里面的代码全部是由主线程执行。因为并行队列里的所有任务所对应的分线程也已经结束。监听到任务结束自动将监听方法里面的代码交由主线程执行。这也就是说，其实管理并行队列里所有任务的组<code>group</code>的监听方法其实本质上就是就是并行队列里所有任务都结束后返回到主线程以便进行下一步操作。</p>
</li>
<li><p>如果我们想要创建多个并行对列，那么又如何确定哪一个并行队列率先执行呢，答案是，根据并行队列的优先级来进行判断。创建有优先级的并行队列的方法为dispatch_queue_t queue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)。当然在这里将并行队列的优先级设置为了默认，也就相当于又增加了一种创建普通并行队列的方法。</p>
</li>
<li><p>如果我想队列里的任务在多少秒之后才开始执行，那么最简单的方法就是在具体的任务里添加睡眠延时<code>sleep(1)</code>，但是的但是这也仅仅适用于串行队列中，而且就算这样可以也会带来一个整体任务进行的延时。对于并行队列来说，只要添加完了任务就会全面开始，根本不会停下来，所以最好的方法就是通过<code>dispatch_time_t  time = dispatch_time(DISPATCH_TIME_NOW, 4ull*NSEC_PER_MSEC)</code>来设置过4秒后再通过<code>dispatch_after(time, queue, ^{})</code>将任务添加到队列<code>queue</code>中。这样就可以完美的实现至少在多少秒后再进行某一个任务。6、无论在串行队列还是在并行队列中，有时候我们想要某个任务只进行一次，就算这是一个死循环的队列，也要保证某个任务只被执行一次，方法就是先用<code>static  dispatch_once_t  onceTaken</code>确定谓词<code>onceTaken</code> ，用来保证<code>dispatch_once(&amp;onceTaken,^{ })</code>方法里的代码也就是任务将从始至终只会被执行一次。</p>
</li>
</ul>
<blockquote>
<p>#互斥锁</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@synchronized(锁对象) &#123; // 需要锁定的代码  &#125;</div><div class="line"></div><div class="line">static id _instance;</div><div class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone</div><div class="line">&#123;</div><div class="line">    @synchronized(self) &#123;</div><div class="line">        if (_instance == nil) &#123;</div><div class="line">            _instance = [super allocWithZone:zone];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return _instance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (instancetype)sharedInstance</div><div class="line">&#123;</div><div class="line">    @synchronized(self) &#123;</div><div class="line">        if (_instance == nil) &#123;</div><div class="line">            _instance = [[self alloc] init];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return _instance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)copyWithZone:(NSZone *)zone</div><div class="line">&#123;</div><div class="line">    return _instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优点：能有效防止因多线程抢夺资源造成的数据安全问题<br>缺点：需要消耗大量的CPU资源<br>前提：多条线程抢夺同一块资源<br>线程同步：多条线程在同一条线上执行（按顺序地执行任务）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">atomic：原子属性，为setter方法加锁（默认就是atomic），线程安全，需要消耗大量的资源</div><div class="line">nonatomic：非原子属性，不会为setter方法加锁，非线程安全，适合内存小的移动设备，尽量避免多线程抢夺同一块资源，尽量将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力</div></pre></td></tr></table></figure>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/09/函数编程/" rel="next" title="函数编程">
                <i class="fa fa-chevron-left"></i> 函数编程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://static.pexels.com/photos/33392/portrait-bird-nature-wild.jpg"
               alt="Carden007" />
          <p class="site-author-name" itemprop="name">Carden007</p>
           
              <p class="site-description motion-element" itemprop="description">人生有很多事情急不得，没有白走的路，走每一步都算数。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Carden007</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
